## 排序 + 枚举 + 二分

根据题意并结合 $nums[i]$ 的数据范围为 $1e3$，我们可以通过「枚举」的方式找到 `x`，而对于每个 `x` 的合法性检查，我们需要快速知道 `nums` 中比 `x` 大的数的个数，这可以通过「排序 + 二分」来做。

代码：

* []

```Java
class Solution {
    public int specialArray(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for (int x = 0; x < 1010; x++) {
            int l = 0, r = n - 1;
            while (l < r) {
                int mid = l + r >> 1;
                if (nums[mid] >= x) r = mid;
                else l = mid + 1;
            }
            if (nums[r] >= x && x == n - r) return x;
        }
        return -1;
    }
}
```

* []

```TypeScript
function specialArray(nums: number[]): number {
    const n = nums.length
    nums.sort((a,b)=>a-b)
    for (let x = 0; x < 1010; x++) {
        let l = 0, r = n - 1
        while (l < r) {
            const mid = l + r >> 1
            if (nums[mid] >= x) r = mid
            else l = mid + 1
        }
        if (nums[r] >= x && x == n - r) return x
    }
    return -1
};
```

* 时间复杂度：排序的复杂度为 $O(n\log{n})$；枚举找 `x` 的复杂度为 $O(C\log{n})$，其中 $C = 1e3$ 为 $nums[i]$ 的值域大小
* 空间复杂度：$O(\log{n})$

---

## 排序 + 二分

若不利用 $nums[i]$ 的值域偏小（即值域放大到 $1e9$），我们可以通过「排序 + 两次二分」的操作来做：第一次二分找分割点 `x`（二分范围为 $[0, 1e9]$）；第二次则是在 `getCnt` 函数内部中使用二分来对 `x` 进行合法性检查。

我们知道若真实的特殊值为 `x`，那么在以 `x` 为分割点的数轴上具有「二段性」，假设当前值为 `k`：
* 小于真实特殊值 `x` 的 `k` 值满足「`nums` 中大于等于 `k` 的元素个数超过 `k` 个」
* 大于等于真实特殊值 `x` 的 `k` 值满足「`nums` 中大于等于 `k` 的元素个数不超过 `k` 个」

因此可以通过「二分」来找真实特殊值为 `x`，至于 `x` 的合法检查则和解法一相同，先通过排序确保数组有序，再通过二分的方式来统计大于等于 `x` 的数的个数。

代码：

* []

```Java
class Solution {
    int[] nums;
    public int specialArray(int[] _nums) {
        nums = _nums;
        Arrays.sort(nums);
        int l = 0, r = (int) 1e9;
        while (l < r) {
            int mid = l + r >> 1;
            if (getCnt(mid) <= mid) r = mid;
            else l = mid + 1;
        }
        return getCnt(r) == r ? r : -1;
    }
    int getCnt(int x) {
        int n = nums.length, l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] >= x) r = mid;
            else l = mid + 1;
        }
        return nums[r] >= x ? n - r : 0;
    }
}
```

* []

```TypeScript
let nums: number[]
function specialArray(_nums: number[]): number {
    nums = _nums
    nums.sort((a,b)=>a-b)
    let l = 0, r = 1e9
    while (l < r) {
        const mid = l + r >> 1
        if (getCnt(mid) <= mid) r = mid
        else l = mid + 1
    }
    return getCnt(r) == r ? r : -1
};
function getCnt(x: number): number {
    let n = nums.length, l = 0, r = n - 1
    while (l < r) {
        const mid = l + r >> 1
        if (nums[mid] >= x) r = mid
        else l = mid + 1
    }
    return nums[r] >= x ? n - r : 0
}
```

* 时间复杂度：排序复杂度为 $O(n\log{n})$，二分找答案复杂度为 $O(\log{C} \times \log{n})$
* 空间复杂度：$O(\log{n})$

---

## 模拟（计数 + 枚举）

另外一种除非过大缩放 $nums$ 的长度 $n$，否则仅有代码量优势的做法是使用「计数 + 枚举」的模拟做法。

先使用静态数组对 $nums$ 进行词频统计，随后通过逆序枚举的方式找特殊值 `x`，同时使用 `tot` 统计遍历过的桶的总元素个数，当满足 `tot = x` 时，返回结果。

代码：

* []

```Java
class Solution {
    public int specialArray(int[] nums) {
        int[] cnts = new int[1010];
        for (int x : nums) cnts[x]++;
        for (int i = 1009, tot = 0; i >= 0; i--) {
            tot += cnts[i];
            if (i == tot) return i;
        }
        return -1;
    }
}
```

* []

```TypeScript
function specialArray(nums: number[]): number {
    const cnts = new Array<number>(1010).fill(0)
    for (let x of nums) cnts[x]++
    for (let i = 1009, tot = 0; i >= 0; i--) {
        tot += cnts[i]
        if (tot == i) return i
    }
    return -1
};
```

* 时间复杂度：$O(n + C)$，其中 $C = 1e3$ 为 $nums[i]$ 的值域大小
* 空间复杂度：$O(C)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
