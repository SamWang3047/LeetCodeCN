## 双指针 + 构造 + 打表

我们将相关的字符串分为三类：**题目描述的神奇字符串 `s` 称为“原串”，对 `s` 进行连续段划分所得的串叫“划分串”，对划分串进行计数的串叫“计数串”**。

解题的核心思路：**由于划分串是对原串的划分，同时计数串又与原串相同，因此可得三类串均只有 `1` 和 `2` 两种数值。即可知划分串的每段长度只能是「长度为 `1`」或「长度为 `2`」，利用划分串的每段构造长度有限，我们可以通过「简单分情况讨论」的方式进行构造**。

具体的，我们需要利用「原串和计数串的相同的性质」对 `s` 进行构造：不难发现计数串总是不长于原串，因此我们可以使用变量 `i` 来记录当前构造到原串位置，使用变量 `j` 来记录计数串对应到的实际位置。

不失一般性假设当前构造到 `s` 中的某一位为 `last`，而计数串对应的实际位置为 `t`，由于两者均只有 `1` 和 `2` 两种可能，我们可以对其进行简单的分情况讨论（可见代码注释）。

> 一些细节：由于神奇字符串起始字符固定，构造逻辑固定，因此神奇字符串唯一固定。
> 我们可以采取 `static` 代码块的方式进行打表预处理（`Java` 中的 `static` 代码块只会在类加载的过程执行一次，而 `LC` 的测评机制是实例化多个 `Solution` 对象来跑多个样例，但 `Solution` 类仍只会被加载一次，即 `static` 在多个样例测评中只会被执行一次。

代码：

* []

```Java
class Solution {
    static int N = 100010;
    static int[] f = new int[N];
    static {
        StringBuilder sb = new StringBuilder();
        sb.append("01"); // 首位多加一个 0 作为哨兵
        for (int i = 1, j = 1, cnt = 0; i < N; j++) {
            int last = sb.charAt(sb.length() - 1) - '0', t = sb.charAt(j) - '0';
            if (last == 1) {
                if (t == 1) {
                    // 当原串当前字符是 1，而计数串当前字符为 1 
                    // 往后构造形成的原串只能是 12，原串指针后移一位
                    sb.append("2");
                    f[i] = ++cnt; i++;
                } else {
                    // 当原串当前字符是 1，而计数串当前字符为 2
                    // 往后构造形成的原串只能是 112，此时同步更新 f[i + 1]，原串指针后移两位
                    sb.append("12");
                    f[i] = ++cnt; f[i + 1] = ++cnt; i += 2;
                }
            } else {
                if (t == 1) {
                    // 当原串当前字符是 2，而计数串当前字符为 1 
                    // 往后构造形成的原串只能是 21，原串指针后移一位
                    sb.append("1");
                    f[i] = cnt; i++;
                } else {
                    // 当原串当前字符是 2，而计数串当前字符为 2
                    // 往后构造形成的原串只能是 221，原串指针后移两位
                    sb.append("21");
                    f[i] = f[i + 1] = cnt; i += 2;
                }
            }
        }
    }
    public int magicalString(int n) {
        return f[n];
    }
}
```

* []

```TypeScript
function magicalString(n: number): number {
    let str = '01' // 首位多加一个 0 作为哨兵
    const f = new Array<number>(n + 10).fill(0)
    for (let i = 1, j = 1, cnt = 0; i <= n; j++) {
        const last = str[str.length - 1], t = str[j]
        if (last == '1') {
            if (t == '1') {
                // 当原串当前字符是 1，而计数串当前字符为 1 
                // 往后构造形成的原串只能是 12，原串指针后移一位
                str += '2'
                f[i] = ++cnt; i++
            } else {
                // 当原串当前字符是 1，而计数串当前字符为 2
                // 往后构造形成的原串只能是 112，此时同步更新 f[i + 1]，原串指针后移两位
                str += '12'
                f[i] = ++cnt; f[i + 1] = ++cnt; i += 2
            }
        } else {
            if (t == '1') {
                // 当原串当前字符是 2，而计数串当前字符为 1 
                // 往后构造形成的原串只能是 21，原串指针后移一位
                str += '1'
                f[i] = cnt; i++
            } else {
                // 当原串当前字符是 2，而计数串当前字符为 2
                // 往后构造形成的原串只能是 221，原串指针后移两位
                str += '21'
                f[i] = f[i + 1] = cnt; i += 2
            }
        }
    }
    return f[n]
}
```

* []

```Python
class Solution:
    def magicalString(self, n: int) -> int:
        ss = '01' # 首位多加一个 0 作为哨兵
        i, j, cnt = 1, 1, 0
        f = [0] * (n + 10)
        while i <= n:
            last, t = ss[i], ss[j]
            if last == '1':
                if t == '1':
                    # 当原串当前字符是 1，而计数串当前字符为 1 
                    # 往后构造形成的原串只能是 12，原串指针后移一位
                    ss += '2'
                    f[i], cnt, i = cnt + 1, cnt + 1, i + 1
                else:
                    # 当原串当前字符是 1，而计数串当前字符为 2
                    # 往后构造形成的原串只能是 112，此时同步更新 f[i + 1]，原串指针后移两位
                    ss += '12'
                    f[i], f[i + 1], cnt, i = cnt + 1, cnt + 2, cnt + 2, i + 2
            else:
                if t == '1':
                    # 当原串当前字符是 2，而计数串当前字符为 1 
                    # 往后构造形成的原串只能是 21，原串指针后移一位
                    ss += '1'
                    f[i], i = cnt, i + 1
                else:
                    # 当原串当前字符是 2，而计数串当前字符为 2
                    # 往后构造形成的原串只能是 221，原串指针后移两位
                    ss += '21'
                    f[i], f[i + 1], i = cnt, cnt, i + 2
            j += 1
        return f[n]
```

* 时间复杂度：$O(n)$，若将 `static` 打表逻辑放到本地进行，能够减少构造的计算量，但仍会有创建答案数组的 $O(n)$ 开销，因此为均摊 $O(1)$
* 空间复杂度：$O(n)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://acoier.com/oimg/gzh-qrcode.webp)，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
