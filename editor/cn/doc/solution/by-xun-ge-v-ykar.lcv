### 解题思路

如果不进行任何优化进行搜索，需要按 presses 次，每次有 4 种选择，那么一共有 4^presses 种按动选择，每种选择消耗 O(n) 时间计算状态，则最终的时间复杂度为 O(n×4^presses)。经过思考，可以从以下角度降低搜索空间。

首先，不需要考虑按钮按动的顺序，而只需要考虑每个按钮被按了几次，在按钮按动次数一样的情况下，顺序不影响灯泡最后的状态。更进一步地，不需要考虑每个按钮具体被按了几次，而只需要考虑被按了奇数次还是偶数次即可，某个键每多按或少按 22 次及其倍数次，也不影响最后的状态。

其次，观察每个按钮的效果，可以发现所有按钮可以根据编号划分为以下 4 组，周期为 6，下列编号中 k≥0：

- 编号为 6k+1，受按钮 1,3,4 影响；
- 编号为 6k+2,6k+6，受按钮 1,2 影响；
- 编号为 6k+3,6k+5，受按钮 1,3 影响；
- 编号为 6k+4，受按钮 1,2,4 影响。

因此，只需要考虑四个灯泡，即可知道所有灯泡最后的状态了。

编写代码时，可以用一个长度为 4 数组 pressArr 表示 4 个按钮的按动情况。一个整数 status 表示四组灯泡亮灭的状态。最后计算遇到过几种不同的状态即可。

### 代码

* c

```c
int flipLights(int n, int presses){
    //不按开关
    if (presses == 0) {
        return 1;
    }
    //特殊情况处理
    if (n == 1) {
        return 2;
    } else if (n == 2) {
        //特殊情况
        return presses == 1 ? 3 : 4;
    } else {
        //n >= 3
        return presses == 1 ? 4 : presses == 2 ? 7 : 8;
    }
    return 0;
}
```

